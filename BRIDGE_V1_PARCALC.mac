! BRIDGE_V1_PARCALC


GEO_chordOff = 0
*if,GEO_deckRadius,ne,0,then
  GEO_chordOff = (1/2)*sqrt(4*(GEO_deckRadius**2)-(GEO_deckLength**2))
*endif


!!                                                                                                !!
!! 2.2 GEOMETRY                                                                                   !!
!!                                                                                                !!

!! 2.2.1 SUPERSTRUCTURE                                                                           !!
!!                                                                                                !!
! Position identifier at each extremity of the bridge
*del,GEO_longPosKey
*dim,GEO_longPosKey,char,2
GEO_longPosKey(1)='BEG','END'

! Deck width at bridge's extremities
*del,GEO_deckWidths,,nopr
*dim,GEO_deckWidths,,2
GEO_deckWidths(1)=GEO_deckWidth_beg,GEO_deckWidth_end

! Deck offsets (along Y)
*if,GEO_deckRadius,ne,0,then
  GEO_deckOff_beg = -GEO_deckWidth_beg/2
  GEO_deckOff_end = -GEO_deckWidth_end/2
*endif

*del,GEO_deckOffsets,,nopr
*dim,GEO_deckOffsets,,2
GEO_deckOffsets(1)=GEO_deckOff_beg,GEO_deckOff_end

! Determine position of the girders
*if,GEO_uniGirderSpacing,EQ,1,THEN
  *do,deckExtremity,1,2,1
    deckWidth=GEO_deckWidths(deckExtremity)
    deckOffset=GEO_deckOffsets(deckExtremity)
    pos=GEO_longPosKey(deckExtremity)

    totalDist=deckWidth-(GEO_leftSlabHang+GEO_rightSlabHang)
    girderDist=totalDist/(GEO_girderCount-1)
    *del,GEO_girderY_%pos%
    *dim,GEO_girderY_%pos%,ARRAY,GEO_girderCount
    *vfill,GEO_girderY_%pos%,ramp,deckOffset+GEO_leftSlabHang,girderDist
  *enddo
*endif

! Determine position of the supports
*if,GEO_supportOpt,eq,0,then
  ! Evenly spaced supports
  supportDist=GEO_deckLength/(GEO_supportCount-1)
  *del,GEO_supportX,,nopr
  *dim,GEO_supportX,,GEO_supportCount
  xPos=0
  *do,nthSupport,1,GEO_supportCount,1
    GEO_supportX(nthSupport) = xPos
    xPos                     = xPos+supportDist
  *enddo
*endif

! Location of first and last supports
s1Offset = GEO_supportX(1)
s2Offset = GEO_supportX(GEO_supportCount)

! Calculate span lengths
GEO_spanCount = GEO_supportCount-1
*del,GEO_spanLengths
*dim,GEO_spanLengths,ARRAY,GEO_spanCount
*do,nthSpan,1,GEO_spanCount,1
  spanLength=GEO_supportX(nthSpan+1)-GEO_supportX(nthSpan)
  GEO_spanLengths(nthSpan)=ABS(spanLength)
*enddo
*vscfun,minSpanLength,min,GEO_spanLengths
*vscfun,maxSpanLength,max,GEO_spanLengths

! Calculate positions of midspans
GEO_midspanCount = GEO_supportCount-1
*del,GEO_midspanX,,nopr
*dim,GEO_midspanX,,GEO_midspanCount
*do,nthMid,1,GEO_midspanCount,1
  x1                   = GEO_supportX(nthMid)
  x2                   = GEO_supportX(nthMid+1)
  xMid                 = (x1+x2)/2
  GEO_midspanX(nthMid) = xMid
*enddo

! Calculate wheel transversal offsets
*afun,deg
skewedDeltaY=GEO_deckLength*tan(LOAD_ltSkewness)
*afun,rad

LOAD_wheelCount = LOAD_ltCount*2

*del,LOAD_ltWheelOff_beg,,nopr
*del,LOAD_ltWheelOff_end,,nopr
*dim,LOAD_ltWheelOff_beg,,LOAD_wheelCount,LOAD_ltTransScenarioCount
*dim,LOAD_ltWheelOff_end,,LOAD_wheelCount,LOAD_ltTransScenarioCount

*do,nthLTtransScenario,1,LOAD_ltTransScenarioCount,1
  *do,nthLine,1,LOAD_ltCount,1
    LOAD_ltWheelOff_beg(nthLine*2-1 , nthLTtransScenario) = LOAD_ltLineOff(nthLine, nthLTtransScenario)-(LOAD_ltWidth/2)
    LOAD_ltWheelOff_beg(nthLine*2   , nthLTtransScenario) = LOAD_ltLineOff(nthLine, nthLTtransScenario)+(LOAD_ltWidth/2)
    LOAD_ltWheelOff_end(nthLine*2-1 , nthLTtransScenario) = LOAD_ltLineOff(nthLine, nthLTtransScenario)-(LOAD_ltWidth/2)+skewedDeltaY
    LOAD_ltWheelOff_end(nthLine*2   , nthLTtransScenario) = LOAD_ltLineOff(nthLine, nthLTtransScenario)+(LOAD_ltWidth/2)+skewedDeltaY
  *enddo
*enddo

! Calculate X coordinates of gerber connections
*voper,activeGerber,GEO_gerberL,gt,0
*vscfun,GEO_gerberCount,sum,activeGerber
*if,GEO_gerberCount,eq,0,then
  GEO_gerberStatus=0
*endif

*if,GEO_gerberStatus,eq,1,then

  *del , GEO_gerberX_sub ,  , nopr
  *del , GEO_gerberX_add ,  , nopr
  *del , GEO_gerberX_i   ,  , nopr
  *del , GEO_gerberX_j   ,  , nopr
  *del , GEO_gerberX_m   ,  , nopr
  *del , GEO_gerberX_n   ,  , nopr
  *dim , GEO_gerberX_sub ,  , GEO_supportCount
  *dim , GEO_gerberX_add ,  , GEO_supportCount

  ! X coordinate at tubular column faces
  *voper,GEO_gerberX_sub,GEO_supportX,sub,GEO_columnDepth/2
  *voper,GEO_gerberX_add,GEO_supportX,add,GEO_columnDepth/2

  *vmask,activeGerber
  *vfun,GEO_gerberX_m,comp,GEO_gerberX_sub
  *vmask,activeGerber
  *vfun,GEO_gerberX_n,comp,GEO_gerberX_add

  ! X coordinate at gerber tips
  *voper,GEO_gerberX_sub,GEO_gerberX_sub,sub,GEO_gerberL
  *voper,GEO_gerberX_add,GEO_gerberX_add,add,GEO_gerberL

  *vmask,activeGerber
  *vfun,GEO_gerberX_i,comp,GEO_gerberX_sub
  *vmask,activeGerber
  *vfun,GEO_gerberX_j,comp,GEO_gerberX_add

*endif

! Calculate positions: supports, midspans, gerber connections
BRIDGE_V1_XTOCHI , 'GEO_supportChi' , 'GEO_supportX'
BRIDGE_V1_XTOCHI , 'GEO_midspanChi' , 'GEO_midspanX'
GEO_supportChi_0 = GEO_supportChi(1)
GEO_supportChi_L = GEO_supportChi(GEO_supportCount)

*do,nthPier,1,GEO_pierCount,1 ! TODO  used before it is defined

*enddo

*if,GEO_gerberStatus,eq,1,then
  BRIDGE_V1_XTOCHI, 'GEO_gerberChi_i', 'GEO_gerberX_i'
  BRIDGE_V1_XTOCHI, 'GEO_gerberChi_j', 'GEO_gerberX_j'
  BRIDGE_V1_XTOCHI, 'GEO_gerberChi_m', 'GEO_gerberX_m'
  BRIDGE_V1_XTOCHI, 'GEO_gerberChi_n', 'GEO_gerberX_n'
*endif

LOAD_ltWheelPathCount = LOAD_wheelCount*LOAD_ltTransScenarioCount

*del , GEO_WHEELPATH_arcOffsets ,  , nopr
*dim , GEO_WHEELPATH_arcOffsets ,  , LOAD_ltWheelPathCount

nthPath = 0
*do,nthLTtransScenario,1,LOAD_ltTransScenarioCount,1
  *do,nthLT,1,LOAD_wheelCount,1
    yBeg    = LOAD_ltWheelOff_beg(nthLT,nthLTtransScenario)
    nthPath = nthPath+1
    GEO_WHEELPATH_arcOffsets(nthPath) = yBeg
  *enddo
*enddo

*del,GEO_FOOTPATH_arcOffsets,,nopr
*dim,GEO_FOOTPATH_arcOffsets,,2
GEO_FOOTPATH_arcOffsets(1) = GEO_deckOff_beg+GEO_footpathLeft_beg
GEO_FOOTPATH_arcOffsets(2) = GEO_deckOff_beg+GEO_deckWidth_beg-GEO_footpathRight_beg

! Positions used to slice longitudinally
arrjoin,'CS_slice','CS_girders','CS_loadTrains','CS_barriers','CS_leftFootpath','CS_rightFootpath'

arrjoin , 'GEO_arc_offsets' , 'GEO_WHEELPATH_arcOffsets' , 'GEO_FOOTPATH_arcOffsets' , 'LOAD_barrierOffset_beg'



!! 2.2.2 MESOSTRUCTURE  *** this needs revising ***                                               !!
!!                                                                                                !!

! TODO: check temporarily removed (has to be redesigned for skewed multi-span bridges)
! ! Check width of the frame
! leftGirderY=GEO_girderY_beg(GEO_girderCount)
! rightGirderY=GEO_girderY_beg(1)
! minFrameWidth=rightGirderY-leftGirderY
! *if,GEO_frameWidth,LT,minFrameWidth,THEN
!    GEO_frameWidth=minFrameWidth
!    *msg,GEO_frameWidth
! WARNING: Frame width incompatible with girder layout. GEO_FRAMEWIDTH increased to %G.
! *endif

! Calculate length of the left & right frame girder cantilevers
GEO_frameGirderLeft=(GEO_frameWidth-GEO_columnSpacing)/2
GEO_frameGirderRight=GEO_frameGirderLeft

! Calculate column length
*if,SEC_offset,EQ,1,THEN
   GEO_colLength=GEO_frameHeight-FRAMEGIRDER_h
*else
   GEO_colLength=GEO_frameHeight
*endif

! Calculate the vertical position of the frame girder keypoints
*if,SEC_offset,EQ,0,THEN
  zFrameTop = 0
*elseif,SEC_offset,EQ,1,THEN
  zFrameTop = 0-GIRDER_d(1)-FRAMEGIRDER_h !! TODO: contemplate multiple girder heights
*endif

! Calculate the vertical position of the base of the columns
zFrameBot=zFrameTop-GEO_colLength

! TODO: array parameter GEO_columnY has been replaced with GEO_columnY_<supportNum>.
!       Account for this change in the rest of the code.

! Calculate key Y coordinates for frame girders
! TODO: this does not contemplate tubular pier columns
yCenterBeg     = GEO_deckOff_beg+(GEO_deckWidth_beg/2)
yCenterEnd     = GEO_deckOff_end+(GEO_deckWidth_end/2)
yCenterDelta   = yCenterEnd-yCenterBeg
deckWidthDelta = GEO_deckWidth_end-GEO_deckWidth_beg

*do,nthFrame,1,GEO_supportCount,1

  ! Get X-coordinate at this support
  xSupport            = GEO_supportX(nthFrame)
  skewnessScaleFactor = xSupport/GEO_deckLength

  ! Calculate deck width
  deckWidth=deckWidthDelta*skewnessScaleFactor+GEO_deckWidth_beg

  ! Calculate Y center
  yCenter=yCenterDelta*skewnessScaleFactor+yCenterBeg

  ! Calculate frame girder ends Y coordinates
  *del,GEO_frameGirderEndsY_%nthFrame%,,nopr
  *dim,GEO_frameGirderEndsY_%nthFrame%,,2
  GEO_frameGirderEndsY_%nthFrame%(1)=yCenter-(deckWidth/2), yCenter+(deckWidth/2)

  ! Calculate column Y coordinates
  *del,GEO_columnY_%nthFrame%,,nopr
  *dim,GEO_columnY_%nthFrame%,,2
  GEO_columnY_%nthFrame%(1)=yCenter-(GEO_columnSpacing/2), yCenter+(GEO_columnSpacing/2)

  ! Calculate girder Y
  *del,girder_y,,nopr
  *vfact,1,1-skewnessScaleFactor,skewnessScaleFactor
  *voper,girder_y,GEO_girderY_beg,add,GEO_girderY_end

  ! Compose key-Y location array with the following positions:
  !    left & right columns
  !    left & right extremities
  !    girder intersections
  arrjoin,'y_coords','girder_y','GEO_frameGirderEndsY_%nthFrame%','GEO_columnY_%nthFrame%'
  arruniq,'y_coords','GEO_frameGirderY_%nthFrame%',1

  ! TODO: Currently using deck width at support as frame width.
  !       For a permanent solution, frame width has to be given at each support.

*enddo

! Check compatibility between water level and column height
*if,GEO_waterHeight,GE,GEO_colLength,THEN
   GEO_waterHeight=GEO_colLength-0.1
   *msg,WARN,GEO_waterHeight
WARNING: Water level incompatible with frame height. GEO_WATERHEIGHT reduced to %G.
*endif
!
!
!! 2.2.3 INFRASTRUCTURE   *** this needs revising ***                                             !!
!!                                                                                                !!
! Force single pile cap option for tubular piers
*if,GEO_frameOpt,eq,1,then
  GEO_capOpt = 1
*endif

! Calculate pile lengths
*if,GEO_pileOpt,eq,0,then
  ! Uniform lengths
  *del,GEO_pileLengths,,nopr
  *dim,GEO_pileLengths,,GEO_SupportCount
  *vfill,GEO_pileLengths,ramp,GEO_pileL,0
*endif

! Initialize pile position arrays
*del , GEO_pileXL ,  , nopr
*del , GEO_pileYL ,  , nopr
*dim , GEO_pileXL ,  , GEO_pileCount
*dim , GEO_pileYL ,  , GEO_pileCount

! Calculate relative coordinates of the piles in the pile cap
*if,GEO_pileCount,EQ,2,THEN
   ! Two piles
   *if,GEO_pileConfig,EQ,'A',THEN
      GEO_pileXL(1)        = 0,0
      GEO_pileYL(1)        = -GEO_pileDistTran/2,GEO_pileDistTran/2
      GEO_pileCapMinLength = (GEO_pileDistTran)+(2*PILE_d)
      GEO_pileCapMinWidth  = (2*PILE_d)
   *elseif,GEO_pileConfig,EQ,'B',THEN
      GEO_pileXL(1)        = GEO_pileDistLong/2,-GEO_pileDistLong/2
      GEO_pileYL(1)        = 0,0
      GEO_pileCapMinLength = (2*PILE_d)
      GEO_pileCapMinWidth  = (GEO_pileDistLong)+(2*PILE_d)
   *endif

*elseif,GEO_pileCount,EQ,3,THEN
   ! Three piles
   *if,GEO_pileConfig,EQ,'A',THEN
      GEO_pileXL(1)        = 0                 , 0 , 0
      GEO_pileYL(1)        = -GEO_pileDistTran , 0 , GEO_pileDistTran
      GEO_pileCapMinLength = (2*GEO_pileDistTran)+(2*PILE_d)
      GEO_pileCapMinWidth  = (2*PILE_d)
   *elseif,GEO_pileConfig,EQ,'B',THEN
      GEO_pileXL(1)        = GEO_pileDistLong , 0 , -GEO_pileDistLong
      GEO_pileYL(1)        = 0                , 0 , 0
      GEO_pileCapMinLength = (2*PILE_d)
      GEO_pileCapMinWidth  = (2*GEO_pileDistLong)+(2*PILE_d)
   *elseif,GEO_pileConfig,EQ,'C',THEN
      GEO_pileXL(1)        = GEO_pileDistLong*(SQRT(3)/6) , GEO_pileDistLong*(SQRT(3)/6) , -GEO_pileDistLong*(SQRT(3)/3)
      GEO_pileYL(1)        = -GEO_pileDistTran/2          , GEO_pileDistTran/2           , 0
      GEO_pileCapMinLength = (GEO_pileDistTran)+(2*PILE_d)
      GEO_pileCapMinWidth  = ((2/3)*(SQRT(3))*GEO_pileDistLong)+(2*PILE_d)
   *endif

*elseif,GEO_pileCount,EQ,4,THEN
   ! Four piles
   *if,GEO_pileConfig,EQ,'A',THEN
      GEO_pileXL(1)        = GEO_pileDistLong/2  , GEO_pileDistLong/2 , -GEO_pileDistLong/2 , -GEO_pileDistLong/2
      GEO_pileYL(1)        = -GEO_pileDistTran/2 , GEO_pileDistTran/2 , -GEO_pileDistTran/2 , GEO_pileDistTran/2
      GEO_pileCapMinLength = (GEO_pileDistTran)+(2*PILE_d)
      GEO_pileCapMinWidth  = (GEO_pileDistLong)+(2*PILE_d)
   *elseif,GEO_pileConfig,EQ,'B',THEN
      GEO_pileXL(1)        = 0                     , 0                   , 0                  , 0
      GEO_pileYL(1)        = -1.5*GEO_pileDistTran , -GEO_pileDistTran/2 , GEO_pileDistTran/2 , 1.5*GEO_pileDistTran
      GEO_pileCapMinLength = (3*GEO_pileDistTran)+(2*PILE_d)
      GEO_pileCapMinWidth  = (2*PILE_d)
   *elseif,GEO_pileConfig,EQ,'C',THEN
      GEO_pileXL(1)        = 1.5*GEO_pileDistLong , GEO_pileDistLong/2 , -GEO_pileDistLong/2 , -1.5*GEO_pileDistLong
      GEO_pileYL(1)        = 0                    , 0                  , 0                   , 0
      GEO_pileCapMinLength = (2*PILE_d)
      GEO_pileCapMinWidth  = (3*GEO_pileDistLong)+(2*PILE_d)
   *endif

*elseif,GEO_pileCount,EQ,5,THEN
   ! Five piles
   *if,GEO_pileConfig,EQ,'A',THEN
      GEO_pileXL(1)        = GEO_pileDistLong*(SQRT(2)/2)  , GEO_pileDistLong*(SQRT(2)/2) , 0 , -GEO_pileDistLong*(SQRT(2)/2) , -GEO_pileDistLong*(SQRT(2)/2)
      GEO_pileYL(1)        = -GEO_pileDistTran*(SQRT(2)/2) , GEO_pileDistTran*(SQRT(2)/2) , 0 , -GEO_pileDistTran*(SQRT(2)/2) , GEO_pileDistTran*(SQRT(2)/2)
      GEO_pileCapMinLength = ((SQRT(2)*GEO_pileDistTran)+(2*PILE_d)
      GEO_pileCapMinWidth  = ((SQRT(2)*GEO_pileDistLong)+(2*PILE_d)
   *elseif,GEO_pileConfig,EQ,'B',THEN
      GEO_pileXL(1)        = (0.85065)*GEO_pileDistLong , (0.26287)*GEO_pileDistLong  , (0.26287)*GEO_pileDistLong , -(0.68819)*GEO_pileDistLong , -(0.68819)*GEO_pileDistLong
      GEO_pileYL(1)        = 0                          , -(0.80902)*GEO_pileDistTran , (0.80902)*GEO_pileDistTran , -(0.5)*GEO_pileDistTran     , (0.5)*GEO_pileDistTran
      GEO_pileCapMinLength = ((1.61804)*GEO_pileDistTran)+(2*PILE_d)
      GEO_pileCapMinWidth  = ((1.70130)*GEO_pileDistLong)+(2*PILE_d)
   *endif

*elseif,GEO_pileCount,EQ,6,THEN
   ! Six piles
   *if,GEO_pileConfig,EQ,'A',THEN
      GEO_pileXL(1)        = GEO_pileDistLong/2 , GEO_pileDistLong/2 , GEO_pileDistLong/2 , -GEO_pileDistLong/2 , -GEO_pileDistLong/2 , -GEO_pileDistLong/2
      GEO_pileYL(1)        = -GEO_pileDistTran  , 0                  , GEO_pileDistTran   , -GEO_pileDistTran   , 0                   , GEO_pileDistTran
      GEO_pileCapMinLength = (2*GEO_pileDistTran)+(2*PILE_d)
      GEO_pileCapMinWidth  = (GEO_pileDistLong)+(2*PILE_d)
   *elseif,GEO_pileConfig,EQ,'B',THEN
      GEO_pileXL(1)        = GEO_pileDistLong    , GEO_pileDistLong   , 0                   , 0                  , -GEO_pileDistLong   , -GEO_pileDistLong
      GEO_pileYL(1)        = -GEO_pileDistTran/2 , GEO_pileDistTran/2 , -GEO_pileDistTran/2 , GEO_pileDistTran/2 , -GEO_pileDistTran/2 , GEO_pileDistTran/2
      GEO_pileCapMinLength = (GEO_pileDistTran)+(2*PILE_d)
      GEO_pileCapMinWidth  = (2*GEO_pileDistLong)+(2*PILE_d)
   *endif

*elseif,GEO_pileCount,EQ,8,THEN
   ! Eight piles:
   d_1 = GEO_pileDistTran
   d_2 = GEO_pileDistLong/2
   *if,GEO_pileConfig,EQ,'A',THEN
      GEO_pileXL(1)        = d_2      , d_2      , d_2     , d_2     , -d_2     , -d_2     , -d_2    , -d_2
      GEO_pileYL(1)        = -1.5*d_1 , -0.5*d_1 , 0.5*d_1 , 1.5*d_1 , -1.5*d_1 , -0.5*d_1 , 0.5*d_1 , 1.5*d_1
      GEO_pileCapMinLength = (3*GEO_pileDistTran)+(2*PILE_d)
      GEO_pileCapMinWidth  = (GEO_pileDistLong)+(2*PILE_d)
   *elseif,GEO_pileConfig,EQ,'B',THEN
      !GEO_pileXL(1)=GEO_pileDistLong,GEO_pileDistLong,0,0,-GEO_pileDistLong,-GEO_pileDistLong
      !GEO_pileYL(1)=-GEO_pileDistTran/2,GEO_pileDistTran/2,-GEO_pileDistTran/2,GEO_pileDistTran/2,-GEO_pileDistTran/2,GEO_pileDistTran/2
      !GEO_pileCapMinLength=(GEO_pileDistTran)+(2*PILE_d)
      !GEO_pileCapMinWidth=(2*GEO_pileDistLong)+(2*PILE_d)
   *endif

*elseif,GEO_pileCount,EQ,9,THEN
   ! Nine piles
   GEO_pileXL(1)        = GEO_pileDistLong  , GEO_pileDistLong , GEO_pileDistLong , 0                 , 0 , 0                , -GEO_pileDistLong , -GEO_pileDistLong , -GEO_pileDistLong
   GEO_pileYL(1)        = -GEO_pileDistTran , 0                , GEO_pileDistTran , -GEO_pileDistTran , 0 , GEO_pileDistTran , -GEO_pileDistTran , 0                 , GEO_pileDistTran
   GEO_pileCapMinLength = (2*GEO_pileDistTran)+(2*PILE_d)
   GEO_pileCapMinWidth  = (2*GEO_pileDistLong)+(2*PILE_d)

*elseif,GEO_pileCount,EQ,10,THEN
   ! Ten piles:
   d_1 = GEO_pileDistTran
   d_2 = GEO_pileDistLong/2
   *if,GEO_pileConfig,EQ,'A',THEN
      GEO_pileXL(1)        = d_2     , d_2  , d_2 , d_2 , d_2   , -d_2   , -d_2 , -d_2 , -d_2 , -d_2
      GEO_pileYL(1)        = - 2*d_1 , -d_1 , 0   , d_1 , 2*d_1 , -2*d_1 , -d_1 , 0    , d_1  , 2*d_1
      GEO_pileCapMinLength = (4*GEO_pileDistTran)+(2*PILE_d)
      GEO_pileCapMinWidth  = (GEO_pileDistLong)+(2*PILE_d)
   *elseif,GEO_pileConfig,EQ,'B',THEN
      !GEO_pileXL(1)=GEO_pileDistLong,GEO_pileDistLong,0,0,-GEO_pileDistLong,-GEO_pileDistLong
      !GEO_pileYL(1)=-GEO_pileDistTran/2,GEO_pileDistTran/2,-GEO_pileDistTran/2,GEO_pileDistTran/2,-GEO_pileDistTran/2,GEO_pileDistTran/2
      !GEO_pileCapMinLength=(GEO_pileDistTran)+(2*PILE_d)
      !GEO_pileCapMinWidth=(2*GEO_pileDistLong)+(2*PILE_d)
   *endif

*endif

! Correct minimum dimensions of pile cap
*if,GEO_pileCapMinLength,LT,COLUMN_cy,THEN
   GEO_pileCapMinLength=COLUMN_cy
*endif
*if,GEO_pileCapMinWidth,LT,COLUMN_cx,THEN
   GEO_pileCapMinWidth=COLUMN_cx
*endif
*if,GEO_capLength,LT,GEO_pileCapMinLength,THEN
   GEO_capLength=GEO_pileCapMinLength
   *msg,WARN,GEO_capLength
WARNING: Pile cap length too small. Size increased to %Gm.
*endif
*if,GEO_capWidth,LT,GEO_pileCapMinWidth,THEN
   GEO_capWidth=GEO_pileCapMinWidth
   *msg,WARN,GEO_capWidth
WARNING: Pile cap width too small. Size increased to %Gm.
*endif

! Calculate X positions in which to slice tubular column piers
zero=0
arrjoin,'xCoords','GEO_pileXL','zero'
arruniq,'xCoords','GEO_xTubeSlice',1
*get,XTubeSliceCount,PARM,GEO_xTubSlice,DIM,X

! Calculate Y positions in which to slice tubular column piers
*if,GEO_frameOpt,eq,0,then
    ! Column-girder frame
    *del,ycols
    *dim,ycols,,2
    ycols(1)=-GEO_columnSpacing/2,GEO_columnSpacing/2
*else
    ! Tubular pier column
    *del,ycols
    *dim,ycols,,1
    ycols(1)=0
*endif

arrjoin,'yCoords','GEO_pileYL','zero','ycols'
arruniq,'yCoords','GEO_yTubeSlice',1
*get,YTubeSliceCount,PARM,GEO_yCapSlice,DIM,X

! Calculate positions in which to slice the pile cap along the YZ plane
*if,GEO_frameOpt,eq,1,then
  ! Tubular pier column
  front = GEO_columnDepth/2
  back  = -GEO_columnDepth/2
*else
  ! Column-girder frame
  front = 0
  back  = 0
*endif
arrjoin,'xCoords','GEO_xTubeSlice','front','back'
arruniq,'xCoords','GEO_xCapSlice',1
*get,XSliceCount,PARM,GEO_xCapSlice,DIM,X

! Calculate positions in which to slice the pile cap along the XZ plane
! TODO: this is gonna be a bitch to fix...
*if,GEO_pileOpt,eq,0,then
  arrjoin,'yCoords','GEO_yTubeSlice','zero'
*elseif,GEO_pileOpt,eq,1,then
  arrjoin,'yCoords','GEO_yTubeSlice','GEO_columnY'
*endif
arruniq,'yCoords','GEO_yCapSlice',1
*get,YSliceCount,PARM,GEO_yCapSlice,DIM,X

! Determine the Z coordinate (vertical position) of the top & bottom of each pile
*if,SEC_offset,EQ,1,THEN
  zPileTop = zFrameBot-PILECAP_h+0.1
*elseif,SEC_offset,EQ,0,THEN
  zPileTop = zFrameBot
*endif


!! 2.2.4 ABUTMENTS                                                                                !!
!!                                                                                                !!
! Abutments status
*if,GEO_ABT_status,eq,0,then
    GEO_ABT1_status=0
    GEO_ABT2_status=0
*elseif,GEO_ABT_status,eq,1,then
    GEO_ABT1_status=1
    GEO_ABT2_status=1
*elseif,GEO_ABT_status,eq,2,then
    GEO_ABT1_status=1
    GEO_ABT2_status=0
*elseif,GEO_ABT_status,eq,3,then
    GEO_ABT1_status=0
    GEO_ABT2_status=1
*endif

! Approach slab status
GEO_ABT1_appSlab=nint(((GEO_ABT1_appSlab>0)<1))
GEO_ABT2_appSlab=nint(((GEO_ABT2_appSlab>0)<1))

! Correct height increment at the beginning of the abutments
*if,GEO_frameTopOffStatus,EQ,0,THEN
  *del,GEO_frameTopOffset
  *dim,GEO_frameTopOffset,ARRAY,GEO_SupportCount
  GEO_ABT1_topOffset=0
  GEO_ABT2_topOffset=0
*else
  GEO_ABT1_topOffset=0 ! GEO_frameTopOffset(1) !! TODO: if this value is not zero, abutment face is inclined
  GEO_ABT2_topOffset=0 ! GEO_frameTopOffset(GEO_supportCount)
*endif

! Y coordinate of the center of each abutment
GEO_ABT1_yc=GEO_deckOff_beg+(GEO_deckWidth_beg/2)
GEO_ABT2_yc=GEO_deckOff_end+(GEO_deckWidth_end/2)

! Surface area at the top of each abutment
*if,GEO_ABT1_appSlab,eq,1,then
  GEO_ABT1_topSurfArea = GEO_ABT1_width*GEO_ABT1_appSlabL
*else
  GEO_ABT1_topSurfArea = GEO_ABT1_width*GEO_ABT1_length
*endif

*if,GEO_ABT2_appSlab,eq,1,then
  GEO_ABT2_topSurfArea = GEO_ABT2_width*GEO_ABT2_appSlabL
*else
  GEO_ABT2_topSurfArea = GEO_ABT2_width*GEO_ABT2_length
*endif


! Calculate number of piles (for curtain option)
pileWidth=SEC_ABT_pile_d-2*GEO_ABT_pileOvlap
*if,GEO_ABT1_type,eq,3,then
    GEO_ABT1_tranPiles=nint((GEO_deckWidth_beg-pileWidth)/pileWidth)
    GEO_ABT1_longPiles=nint(GEO_ABT1_length/pileWidth)
*endif
*if,GEO_ABT2_type,eq,3,then
    GEO_ABT2_tranPiles=nint((GEO_deckWidth_end-pileWidth)/pileWidth)
    GEO_ABT2_longPiles=nint(GEO_ABT2_length/pileWidth)
*endif

! Pile cap size for pile curtain
*if,GEO_ABT1_type,eq,3,then
    GEO_ABT1_pileCapL=GEO_ABT1_length+(GEO_ABT1_pileCapW/2)
*endif
*if,GEO_ABT2_type,eq,3,then
    GEO_ABT2_pileCapL=GEO_ABT2_length+(GEO_ABT2_pileCapW/2)
*endif

! Thin transversal wall depth
*get,parType,parm,GEO_ABT1_thinTranWallDepth,type
*if,parType,ne,0,then
  GEO_ABT1_thinTranWallDepth=0
*endif
*get,parType,parm,GEO_ABT2_thinTranWallDepth,type
*if,parType,ne,0,then
  GEO_ABT2_thinTranWallDepth=0
*endif

! Create abutment geometry arrays
*del,GEO_ABT1_geometry
*dim,GEO_ABT1_geometry,,30
GEO_ABT1_geometry(1)  = GEO_ABT1_type         , GEO_deckWidth_beg  , GEO_deckOff_beg      , GEO_ABT1_yc                , GEO_ABT1_appSlab
GEO_ABT1_geometry(6)  = GEO_ABT1_appSlabL     , GEO_ABT1_height    , GEO_ABT1_length      , GEO_ABT1_longPiles         , GEO_ABT1_pileCapL
GEO_ABT1_geometry(11) = GEO_ABT1_pileCapW     , GEO_ABT1_pileL     , GEO_ABT1_topOffset   , GEO_ABT1_tranPiles         , GEO_ABT1_wings
GEO_ABT1_geometry(16) = GEO_ABT1_wingHa       , GEO_ABT1_wingL     , GEO_ABT1_pileAngle   , GEO_ABT1_suppressLW        , GEO_ABT1_curtainL
GEO_ABT1_geometry(21) = GEO_ABT1_pileFree     , GEO_ABT1_pileShort , GEO_ABT1_trvPileCols , GEO_ABT1_wingPileCols      , GEO_ABT1_wingCapLength
GEO_ABT1_geometry(26) = GEO_ABT1_wingCapWidth , GEO_ABT1_wingAngle , GEO_ABT1_width       , GEO_ABT1_thinTranWallDepth , GEO_ABT1_beamOpt

*del,GEO_ABT2_geometry
*dim,GEO_ABT2_geometry,,30
GEO_ABT2_geometry(1)  = GEO_ABT2_type         , GEO_deckWidth_end  , GEO_deckOff_end      , GEO_ABT2_yc                , GEO_ABT2_appSlab
GEO_ABT2_geometry(6)  = GEO_ABT2_appSlabL     , GEO_ABT2_height    , GEO_ABT2_length      , GEO_ABT2_longPiles         , GEO_ABT2_pileCapL
GEO_ABT2_geometry(11) = GEO_ABT2_pileCapW     , GEO_ABT2_pileL     , GEO_ABT2_topOffset   , GEO_ABT2_tranPiles         , GEO_ABT2_wings
GEO_ABT2_geometry(16) = GEO_ABT2_wingHa       , GEO_ABT2_wingL     , GEO_ABT2_pileAngle   , GEO_ABT2_suppressLW        , GEO_ABT2_curtainL
GEO_ABT2_geometry(21) = GEO_ABT2_pileFree     , GEO_ABT2_pileShort , GEO_ABT2_trvPileCols , GEO_ABT2_wingPileCols      , GEO_ABT2_wingCapLength
GEO_ABT2_geometry(26) = GEO_ABT2_wingCapWidth , GEO_ABT2_wingAngle , GEO_ABT2_width       , GEO_ABT2_thinTranWallDepth , GEO_ABT2_beamOpt

! Abutment extents
GEO_ABT1_xMin=-(GEO_ABT1_length>GEO_ABT1_appSlabL*GEO_ABT1_appSlab)
GEO_ABT1_xMax=0
GEO_ABT2_xMin=GEO_deckLength
GEO_ABT2_xMax=GEO_deckLength+(GEO_ABT2_length>GEO_ABT2_appSlabL*GEO_ABT2_appSlab)

! General span lengths
GEO_genSpanCount = GEO_supportCount-1

*if,GEO_ABT1_status,eq,1,or,GEO_ABT2_status,eq,1,then

  i_init = 0
  *if,GEO_ABT1_status,eq,1,and,GEO_ABT1_appSlab,eq,1,then
    ! Approach slab in first abutment
    GEO_genSpanCount = GEO_genSpanCount+1
    i_init           = 1
  *endif

  i_end = 0
  *if,GEO_ABT1_status,eq,1,and,GEO_ABT2_appSlab,eq,1,then
    ! Approach slab in second abutment
    GEO_genSpanCount = GEO_genSpanCount+1
    i_end            = 1
  *endif

  *del , GEO_genSpanLengths ,  , nopr
  *del , GEO_genSpanLimits  ,  , nopr

  *dim , GEO_genSpanLengths ,  , GEO_genSpanCount
  *dim , GEO_genSpanLimits  ,  , GEO_genSpanCount+1

  *vfun , GEO_genSpanLengths(i_init+1) , copy , GEO_spanLengths(1)
  *vfun , GEO_genSpanLimits(i_init+1)  , copy , GEO_supportX(1)

  *if,i_init,eq,1,then
    GEO_genSpanLengths(1) = GEO_ABT1_appSlabL
    GEO_genSpanLimits(1)  = -GEO_ABT1_appSlabL
  *endif

  *if,i_end,eq,1,then
    GEO_genSpanLengths(GEO_genSpanCount)  = GEO_ABT2_appSlabL
    GEO_genSpanLimits(GEO_genSpanCount+1) = GEO_deckLength+GEO_ABT2_appSlabL
  *endif

*else
  ! No abutments
  *del , GEO_genSpanLengths ,  , nopr
  *del , GEO_genSpanLimits  ,  , nopr
  *dim , GEO_genSpanLengths ,  , GEO_supportCount-1

  *vfun , GEO_genSpanLengths(1) , copy , GEO_spanLengths
  *vfun , GEO_genSpanLimits     , copy , GEO_supportX

*endif

! Number of piers (excluding abutments)
GEO_pierCount = GEO_supportCount

*if,GEO_ABT1_status,eq,1,then
  GEO_pierCount = GEO_pierCount-1
*endif

*if,GEO_ABT2_status,eq,1,then
  GEO_pierCount = GEO_pierCount-1
*endif

! XZ coordinates of each pier
*if,GEO_frameBotOffStatus,eq,0,then
  *del,GEO_frameBotOffset,,nopr
  *dim,GEO_frameBotOffset,ARRAY,GEO_SupportCount
*endif

*del , GEO_pierX    ,  , nopr
*del , GEO_pierZBot ,  , nopr
*del , GEO_pierZTop ,  , nopr
*dim , GEO_pierX    ,  , GEO_pierCount
*dim , GEO_pierZBot ,  , GEO_pierCount
*dim , GEO_pierZTop ,  , GEO_pierCount
nthPier=0
*do,nthSupport,1,GEO_supportCount,1
    skip=0
    *if,nthSupport,eq,1,and,GEO_ABT1_status,eq,1,then
        skip=1
    *elseif,nthSupport,eq,GEO_supportCount,and,GEO_ABT2_status,eq,1,then
        skip=1
    *endif
    *if,skip,eq,0,then
        nthPier=nthPier+1
        GEO_pierX(nthPier)=GEO_supportX(nthSupport)
        GEO_pierZBot(nthPier)=zFrameBot+GEO_frameBotOffset(nthSupport)
        GEO_pierZTop(nthPier)=zFrameTop+GEO_frameTopOffset(nthSupport)
    *endif
*enddo

! Determine type of mesostructure at each support
*del,GEO_mesoType,,nopr
*dim,GEO_mesoType,,GEO_supportCount

*if,GEO_frameOpt,eq,0,then
  ! Column-girder frame
  *vfill,GEO_mesoType,ramp,CTE_MESO_frame,0
*elseif,GEO_frameOpt,eq,1,then
  ! Tubular pier column
  *vfill,GEO_mesoType,ramp,CTE_MESO_tube,0
*elseif,GEO_frameOpt,eq,2,then
  ! Tubular pier column
  *vfill,GEO_mesoType,ramp,CTE_MESO_beamcap,0
*endif

*if,GEO_gerberStatus,eq,1,then
  *do,nthSupport,1,GEO_supportCount,1
    gerberL = GEO_gerberL(nthSupport)
    *if,gerberL,gt,0,then
      GEO_mesoType(nthSupport) = CTE_MESO_tcolumn
    *endif
  *enddo
*endif

*if,GEO_ABT1_status,eq,1,then
  GEO_mesoType(1) = CTE_MESO_abutment
*endif
*if,GEO_ABT2_status,eq,1,then
  GEO_mesoType(GEO_supportCount) = CTE_MESO_abutment
*endif

! Calculate X coordinates of tubular column faces
*del , GEO_pierX_i ,  , nopr
*del , GEO_pierX_j ,  , nopr
*dim , GEO_pierX_i ,  , GEO_pierCount
*dim , GEO_pierX_j ,  , GEO_pierCount
*voper,GEO_pierX_i,GEO_pierX,sub,GEO_columnDepth/2
*voper,GEO_pierX_j,GEO_pierX,add,GEO_columnDepth/2

! Calculate chi angles of tubular column faces
*if,GEO_deckRadius,gt,0,then
  BRIDGE_V1_XTOCHI,'GEO_pierChi_i','GEO_pierX_i'
  BRIDGE_V1_XTOCHI,'GEO_pierChi_j','GEO_pierX_j'
*endif

!!                                                                                                !!
!! 2.3 LOADS                                                                                      !!
!!                                                                                                !!
! Calculate dynamic impact coefficient
*if,BRIDGE_type,eq,0,then
    ! Highway bridge

    ! Basic impact coefficient (NBR 7188)
    LOAD_baseImpactCoefficient       = (1.35<1+1.06*(20/(minSpanLength+50)))
    ! Additional impact coefficient (used only for slabs less than 5 meters away from a joint -- unused for now)
    LOAD_additionalImpactCoefficient = 1.25
    ! Lane number coefficient (should not be used for slabs -- unused for now)
    LOAD_laneCoefficient             = (0.9>1-0.05*(GEO_laneNumber-2))
    ! Final impact coefficient applied to vehicle loads
    LOAD_dynImpact                   = LOAD_baseImpactCoefficient

*elseif,BRIDGE_type,eq,1,then
    ! Railway bridge (VALE)
    LOAD_dynImpact=1.6

    ! Railway bridge (NBR 7187:2003)
    LOAD_dynImpact=(1600-60*sqrt(minSpanLength)+2.25*minSpanLength)/1000
    LOAD_dynImpact=(LOAD_dynImpact>1.2)

*endif

! Apply impact coefficient to dynamic loads
*get,parType,parm,LOAD_railcarCount,type
*if,parType,ne,0,then
  *if,SOLU_type,eq,0,then
    ! Static analysis
    udlLength=GEO_deckLength
  *elseif,SOLU_type,eq,1,then
    ! Dynamic analysis
    udlLength=0
  *endif
*else
  *if,LOAD_railcarCount,le,0,then
    LOAD_railcarCount=0
  *endif
  udlLength=LOAD_railcarCount
*endif

loadtrain, LOAD_ltName,LOAD_locRep,0,1, udlLength ! Output: LOADTRAIN_VAR_count; LOADTRAIN_ARR_positions; LOADTRAIN_ARR_loads
LOAD_plCount=LOADTRAIN_VAR_count
*del , LOAD_plDist   ,  , nopr
*del , LOAD_plValue  ,  , nopr
*del , LOAD_ltLength ,  , nopr
*vfun , LOAD_plDist  , copy , LOADTRAIN_ARR_positions
*vfun , LOAD_plValue , copy , LOADTRAIN_ARR_loads
LOAD_ltLength=LOADTRAIN_VAR_length

! Calculate horizontal forces
*if,BRIDGE_type,eq,0,then
    ! Highway bridge

*elseif,BRIDGE_type,eq,1,then
    ! Railway bridge

    *if,LOAD_railOpt,eq,0,then
        ! Discontinuous rail:

        ! According to AREMA (lengths input in meters, forces output in N):
        !   f_braking      = 1e3*(200+17.5*loaded_length)
        !   f_accelerating = 1e3*(200*sqrt(loaded_length))

        ! Braking forces
        *del   , arr_f_braking ,                    , nopr
        *voper , arr_f_braking , GEO_genSpanLengths , mult , 17.5
        *voper , arr_f_braking , f_braking          , add  , 200
        *voper , arr_f_braking , arr_f_braking      , mult , 1e3

        ! Accelerating forces
        *del   , arr_f_accelerating ,                    , nopr
        *vfun  , arr_f_accelerating , sqrt               , GEO_genSpanLengths
        *voper , arr_f_accelerating , arr_f_accelerating , mult               , 200
        *voper , arr_f_accelerating , arr_f_accelerating , mult               , 1e3

        ! Total longitudinal forces
        *del   , arr_f_longitudinal ,               , nopr
        *voper , arr_f_longitudinal , arr_f_braking , max  , arr_f_accelerating

    *endif

*endif

! Point-load generated soil pressure calculation method
*get,parType,parm,LOAD_ltPresMethod,type
*if,parType,eq,3,then
  *if,upcase(LOAD_ltPresMethod),eq,'HYDROSTA',then
    LOAD_ltPresMethod = 'HYDROSTA'
  *else
    LOAD_ltPresMethod = 'BOUSSNSQ'
  *endif
*else
  LOAD_ltPresMethod = 'BOUSSNSQ'
*endif

! Combination type: ELU or ELS
*if,LOAD_combination,EQ,1,THEN
   ! Ultimate load: load train as main
   ! Live loads
   *voper,LOAD_plValue,LOAD_gammaQ*LOAD_dynImpact,MULT,LOAD_plValue
   LOAD_vehicleTraffic    = LOAD_vehicleTraffic_k*LOAD_dynImpact*LOAD_gammaQ*LOAD_psi0
   LOAD_pedestrianTraffic = LOAD_pedestrianTraffic_k*LOAD_gammaQ*LOAD_psi0
   LOAD_waterFlow         = LOAD_waterFlow_k*LOAD_gammaQ*LOAD_psi0
   LOAD_columnWind        = LOAD_columnWind_k*LOAD_gammaQ*LOAD_psi0
   LOAD_deckWind          = LOAD_deckWind_k*LOAD_gammaQ*LOAD_psi0
   ! Dead loads
   LOAD_g            = LOAD_g_k*LOAD_gammaG
   LOAD_pav          = LOAD_pav_k*LOAD_gammaG
   LOAD_barrierValue = LOAD_barrierValue_k*LOAD_gammaG

*elseif,LOAD_combination,EQ,2,THEN
   ! Ultimate load: wind/tide as main
   ! Live loads
   *voper,LOAD_plValue,LOAD_gammaQ*LOAD_dynImpact*LOAD_psi0,MULT,LOAD_plValue
   LOAD_vehicleTraffic    = LOAD_vehicleTraffic_k*LOAD_dynImpact*LOAD_gammaQ
   LOAD_pedestrianTraffic = LOAD_pedestrianTraffic_k*LOAD_gammaQ
   LOAD_waterFlow         = LOAD_waterFlow_k*LOAD_gammaQ*LOAD_psi0
   LOAD_columnWind        = LOAD_columnWind_k*LOAD_gammaQ*LOAD_psi0
   LOAD_deckWind          = LOAD_deckWind_k*LOAD_gammaQ*LOAD_psi0
   ! Dead loads
   LOAD_g            = LOAD_g_k*LOAD_gammaG
   LOAD_pav          = LOAD_pav_k*LOAD_gammaG
   LOAD_barrierValue = LOAD_barrierValue_k*LOAD_gammaG

*elseif,LOAD_combination,EQ,3,THEN
   ! Service load ("quase-permanente")
   ! Live loads
   *voper,LOAD_plValue,LOAD_psi2,MULT,LOAD_plValue
   LOAD_vehicleTraffic    = LOAD_vehicleTraffic_k*LOAD_psi2
   LOAD_pedestrianTraffic = LOAD_pedestrianTraffic_k*LOAD_psi2
   LOAD_waterFlow         = LOAD_waterFlow_k*LOAD_psi2
   LOAD_columnWind        = LOAD_columnWind_k*LOAD_psi2
   LOAD_deckWind          = LOAD_deckWind_k*LOAD_psi2
   ! Dead loads
   LOAD_g            = LOAD_g_k
   LOAD_pav          = LOAD_pav_k
   LOAD_barrierValue = LOAD_barrierValue_k

*elseif,LOAD_combination,EQ,4,THEN
   ! Service load ("rara"): load train as main
   ! Live loads
   *voper,LOAD_plValue,1,MULT,LOAD_plValue
   LOAD_vehicleTraffic    = LOAD_vehicleTraffic_k*LOAD_psi1
   LOAD_pedestrianTraffic = LOAD_pedestrianTraffic_k*LOAD_psi1
   LOAD_waterFlow         = LOAD_waterFlow_k*LOAD_psi1
   LOAD_columnWind        = LOAD_columnWind_k*LOAD_psi1
   LOAD_deckWind          = LOAD_deckWind_k*LOAD_psi1
   ! Dead loads
   LOAD_g            = LOAD_g_k
   LOAD_pav          = LOAD_pav_k
   LOAD_barrierValue = LOAD_barrierValue_k

*elseif,LOAD_combination,EQ,5,THEN
   ! Service load ("rara"): wind/tide as main
   ! Live loads
   *voper,LOAD_plValue,LOAD_psi1,MULT,LOAD_plValue
   LOAD_vehicleTraffic    = LOAD_vehicleTraffic_k*LOAD_psi1
   LOAD_pedestrianTraffic = LOAD_pedestrianTraffic_k*LOAD_psi1
   LOAD_waterFlow         = LOAD_waterFlow_k*1
   LOAD_columnWind        = LOAD_columnWind_k*1
   LOAD_deckWind          = LOAD_deckWind_k*1
   ! Dead loads
   LOAD_g            = LOAD_g_k
   LOAD_pav          = LOAD_pav_k
   LOAD_barrierValue = LOAD_barrierValue_k

*elseif,LOAD_combination,EQ,6,THEN
   ! Dead loads (characteristic values)
   ! Live loads
   *voper,LOAD_plValue,0,MULT,LOAD_plValue
   LOAD_vehicleTraffic    = 0
   LOAD_pedestrianTraffic = 0
   LOAD_waterFlow         = 0
   LOAD_columnWind        = 0
   LOAD_deckWind          = 0
   ! Dead loads
   LOAD_g            = LOAD_g_k
   LOAD_pav          = LOAD_pav_k
   LOAD_barrierValue = LOAD_barrierValue_k

*elseif,LOAD_combination,EQ,7,THEN
   ! Live loads (characteristic values)
   ! Live loads
   *voper,LOAD_plValue,1,MULT,LOAD_plValue
   LOAD_vehicleTraffic    = LOAD_vehicleTraffic_k
   LOAD_pedestrianTraffic = LOAD_pedestrianTraffic_k
   LOAD_waterFlow         = LOAD_waterFlow_k
   LOAD_columnWind        = LOAD_columnWind_k
   LOAD_deckWind          = LOAD_deckWind_k
   ! Dead loads
   LOAD_g            = 0
   LOAD_pav          = 0
   LOAD_barrierValue = 0

*elseif,LOAD_combination,EQ,8,THEN
   ! Fatigue analysis ("combinação frequente de fadiga, K.2.1")
   ! Live loads
   *voper,LOAD_plValue,LOAD_psi1,MULT,LOAD_plValue
   LOAD_vehicleTraffic    = LOAD_vehicleTraffic_k*LOAD_psi1
   LOAD_pedestrianTraffic = LOAD_pedestrianTraffic_k*LOAD_psi1
   LOAD_waterFlow         = LOAD_waterFlow_k*LOAD_psi1
   LOAD_columnWind        = LOAD_columnWind_k*LOAD_psi1
   LOAD_deckWind          = LOAD_deckWind_k*LOAD_psi1
   ! Dead loads
   LOAD_g            = LOAD_g_k
   LOAD_pav          = LOAD_pav_k
   LOAD_barrierValue = LOAD_barrierValue_k

*elseif,LOAD_combination,EQ,9,THEN
   ! Service load ("frequente"): load train as main
   ! Live loads
   *voper,LOAD_plValue,1,MULT,LOAD_plValue
   LOAD_vehicleTraffic    = LOAD_vehicleTraffic_k*LOAD_psi2
   LOAD_pedestrianTraffic = LOAD_pedestrianTraffic_k*LOAD_psi2
   LOAD_waterFlow         = LOAD_waterFlow_k*LOAD_psi2
   LOAD_columnWind        = LOAD_columnWind_k*0
   LOAD_deckWind          = LOAD_deckWind_k*0
   ! Dead loads
   LOAD_g            = LOAD_g_k
   LOAD_pav          = LOAD_pav_k
   LOAD_barrierValue = LOAD_barrierValue_k

*endif

! Check load train step
*if,LOAD_ltStep,EQ,0,OR,LOAD_ltStep,GT,GEO_deckLength/2,THEN
   LOAD_ltStep=GEO_deckLength/2
*endif

! Calculate centrifugal force percentage (AREMA)
*if,GEO_deckRadius,ne,0,then
    *afun,deg
    LOAD_degreeOfCurve=2*asin(15.24/GEO_deckRadius)
    *afun,rad
    LOAD_centrifugalPct=4.52e-4*(LOAD_speed**2)*LOAD_degreeOfCurve
*else
    LOAD_centrifugalPct=0
*endif
